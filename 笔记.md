# 源码分析原则
1 寻找入口
2 断点追踪
3 先粗后细
4 精略结合
5 猜想验证

# SQL框架 mybatis 源码分析
 - 类加载器
   - ClassLoader的作用就是将class文件加载到Jvm中 程序就可以正确运行了 但是jvm启动的时候不会一次性加载所有的class文件
   - 而是需要动态加载 如果一次加载那么多jar包和class 那么内存消耗极大
   - Java自带三个加载器 SystemClassLoader[ApplicationClassLoader] ExtraClassLoader BootStrapClassLoader 并且类加载器的选择是通过双亲委派机制 从上倒下加载
   - ![img.png](img.png)


# 分析
 - 第一步读取配置
    //        第一步 读取mybatis文件
    //        通过classLoader来读取文件 并且返回一个输入流
    //        InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml");
    //        其实就是 ClassLoaderWrapper类的getResourceAsStream()方法的下面一行代码
    //        InputStream returnValue = cl.getResourceAsStream(resource);
    //       就是通过classLoader来加载一个流 并且返回一个输入流
    InputStream inputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("mybatis-config.xml");
   - 调用对象路线
   - 
     1 Resouce.getResourceAsStream(路径) 并且返回并调用同名重载方法 getResourceAsStream(路径,ClassLoader) 并且传入null

     2  进入同名构造方法后 通过聚合的ClassLoaderWrapper 来调用并返回该实例的方法 getResourceAsStream(文件路径,ClassLoader)
     
     3 进入 ClassLoaderWrapper 的getResourceAsStream方法后 再次返回并调用他的同名重载方法 getResourceAsStream(文件路径,getClassLoaders(参数的classLoader))
     
     4 进入 方法法 getResourceAsStream(文件路径,ClassLoader[]) 之后 方法内部会遍历循环不为空的类加载器 并且通过类加载器的getResourceAsStream(文件路径) 方法来加载文件输入流 最后返回文件输入流给Client
   - Uml
     - ![img_1.png](img_1.png)


 - 第二步 初始化工厂 SqlSessionFactory 返回 SqlSession
 - 
 - 
         /*
           * 整个调用流程
           *  1 SqlSessionFactory :  new SqlSessionFactoryBuilder().build(inputStream)
           *   2 进入Build方法 执行XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
           *   3 进入 XMLConfigBuilder的构造函数 调用new XPathParser(inputStream, true, props, new XMLMapperEntityResolver())
           *       4 生成XPathParser对象 TODO 内部包含document对象 内容就是Xml的解析结果 里面执行了  commonConstructor(validation, variables, entityResolver);负责成员变量赋值 this.document = createDocument(new InputSource(inputStream));读取Xml文件
           *     5 调用this(刚刚生成的XPathParser对象, environment, props);[TODO this()就是XMLConfigBuilder的构造函数]
           *       6 super(new Configuration()); 调用XMLConfigBuilder的父类BaseBuilder的构造函数 并且进行了成员赋值 将Configuration赋值到了成员变量中 这样子类也可以访问 并且new Configuration()中进行了别名列表初始化 数据结构对应 等等操作 Configuration对象就是Mybatis的核心配置类
           *       7 将参数中的XpathParser对象赋值到成员变量中
           *   8 XMLConfigBuilder的构造函数结束 并且生成了一个实例对象parser
           *   9 调用XMLConfigBuilder的实例对象parser的方法parse() 内部会判断是否已经加载过 如果加载过那么就报错
           *     1 在parse方法中调用了成员方法 parseConfiguration(parser.evalNode("/configuration"))
           *       2 进入XpathParser对象的evalNode方法 内部执行了return evalNode(document, expression);参数为document即xml解析结果 expression即传入的"/configuration" 返回值为XNode
           *          3 evalNode(document,expression)方法内部执行了Node node = (Node) evaluate(expression, root, XPathConstants.NODE);
           *             4 执行XpathParser的成员方法evaluate(expression, root, XPathConstants.NODE) 参数expression是"/configuration" root是document对象
           *                5  XpathParser的成员方法evaluate内部执行了 jdk方法 return xpath.evaluate(expression, root, returnType); 返回一个Object
           *          6 Node node = (Node) evaluate(expression, root, XPathConstants.NODE);执行结束 并且将evaluate返回值Object转型为Node类型 [TODO Node类型 是JDK提供了用于标志Xml文档节点的类]
           *          7 判断Node是否为空 不为空执行   return new XNode(this, node, variables);  TODO 参数(this就是XpathParser node就是生成node节点这里是configuration)   XNode对象 是Mybatis封装的对象 代表Xml节点的一个对象
           *             8 进入XNode构造函数进行成员赋值将 XPathParser Node[configuration] 对象通过参数聚合到类中
           *             9 XNode构造函数执行其余初始化this.name = node.getNodeName(); //configuration
                           这两个函数 都是在解析node 比如获取子节点getChildNodes 获取NodeList
                           this.attributes = parseAttributes(node);
                           this.body = parseBody(node);
                 1 至此parseConfiguration(parser.evalNode("/configuration"));的参数evalNode函数结束 并且返回了一个XNode对象 并且该对象包含了XpathParser(里面有document属性) 并且还有Node对象(包含对应的节点信息)
           *     2 调用parseConfiguration((root.evalNode("properties")) 参数 root就是XNode对象
           *        3 内部通过XNode对象调用该对象的方法evalNode(expression) 并且传入其他节点的名字例如 properties
           *           4 XNode.evalNode内部调用的是 他聚合的xpathParser对象的evalNode方法 return xpathParser.evalNode(node, expression); 并且传入了 node属性[就是刚才聚合的configuration的Node对象] 和外部传入的expression这里是properties
           *             5 然后再次执行 Node node = (Node) evaluate(expression, root, XPathConstants.NODE); 获取对应的Node节点 这里是获取的properties的节点
           *             6 执行 return new XNode(this, node, variables); 进入XNode构造函数进行成员赋值将 XPathParser Node[properties] 对象通过参数聚合到类中
           *     7 至此parseConfiguration(root.evalNode("properties"));的参数evalNode函数结束
           *     8 继续重复上述操作 直到parseConfiguration()函数结束
           *   9 最后SqlSessionFactory的build方法 的内部操作return build(parser.parse())的参数部分结束 并且得到了parser.parse()参数返回的Configuration对象
           *     1 SqlSessionFactory调用build(parser.parse()) 的build(Configuration)方法 内部又调用new DefaultSqlSessionFactory(config)
           *       2  DefaultSqlSessionFactory(config)构造函数 内部执行了赋值操作 this.configuration = configuration; 并且他实现了SqlSession接口 所以可以返回他
           *  1 返回SqlSession实现类  DefaultSqlSessionFactory 也就是return build(parser.parse());
           *
           * */
 - configuration 一部分内容
 - ![img_2.png](img_2.png) ![img_3.png](img_3.png)